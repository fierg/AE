//// Created by fierg on 7/18/23.//#include <stdexcept>template<typename T>class Queue {public:    Queue() : front(nullptr), rear(nullptr) {}    ~Queue() {while (!isEmpty()) {dequeue();}}    void enqueue(const T& value) {        QueueNode* newNode = new QueueNode(value);        if (isEmpty()) {            front = rear = newNode;        } else {            rear->next = newNode;            rear = newNode;        }    }    T dequeue() {        if (isEmpty()) {            throw std::runtime_error("Queue is empty.");        }        QueueNode* temp = front;        front = front->next;        if (front == nullptr) {            rear = nullptr;        }        return temp->data;    }    T getFront() const {        if (isEmpty()) {            throw std::runtime_error("Queue is empty.");        }        return front->data;    }    bool isEmpty() const {        return front == nullptr;    }private:    struct QueueNode {        T data;        QueueNode* next;        QueueNode(const T& value) : data(value), next(nullptr) {}    };    QueueNode* front;    QueueNode* rear;};